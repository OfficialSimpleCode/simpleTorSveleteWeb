var Ce=Object.defineProperty;var Ge=(u,e,t)=>e in u?Ce(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var ne=(u,e,t)=>(Ge(u,typeof e!="symbol"?e+"":e,t),t);import{s as _e,e as _,a as V,t as ie,b as F,d as S,h as j,f as oe,g as A,i as k,k as Fe,l as b,o as Se,c as Oe}from"./scheduler.C3TCnZHI.js";import{S as Je,i as xe,c as pe,a as $e,m as he,t as Ie,b as De,d as ve}from"./index.Lhnxl_wK.js";import{o as te,t as se,w as ae,q as ye,s as He,v as H,x as ue,y as Ee,z as G,C as we,D as We,E as Pe,F as Ne,H as ke,I as Ve,J as je,K as T,L as g,M as Re,N as ze,O as Le,G as qe,u as de,a as p,c as I,P as Ke,Q as be,j as R,R as Qe,S as Xe,W as re,T as Ye,X as Ze,Y as Be,Z as O,_ as le,$ as X,e as y,f as z,a0 as E,a1 as K,a2 as Q,a3 as et,a4 as L,a5 as C,a6 as tt,a7 as st,m as x,a8 as Te,B as Me}from"./business_initializer.urx4IAss.js";import{G as ge}from"./Navbar._O0d0J6N.js";import{$ as at}from"./runtime.oGXtuNGk.js";function rt(u){let e,t,s,n,r,a,i,c,d,o=(u[1]?u[2]?te(u[0]):se(ae[u[0].getDay()],u[3]):`  (${u[2]?te(u[0]):se(ae[u[0].getDay()],u[3])})`)+"",f,$,h,w,l,m,v,J,U,W,P,q,N;return s=new ge({props:{icon:"mdi:date-range",size:22}}),v=new ge({props:{icon:"mdi:clock-time-three-outline",size:22}}),{c(){e=_("div"),t=_("div"),pe(s.$$.fragment),n=V(),r=_("div"),a=_("p"),i=ie(u[5]),c=V(),d=_("p"),f=ie(o),h=V(),w=_("div"),l=V(),m=_("div"),pe(v.$$.fragment),J=V(),U=_("p"),W=ie(u[4]),P=V(),q=_("div"),this.h()},l(D){e=F(D,"DIV",{class:!0});var M=S(e);t=F(M,"DIV",{class:!0});var Z=S(t);$e(s.$$.fragment,Z),n=j(Z),r=F(Z,"DIV",{class:!0});var B=S(r);a=F(B,"P",{dir:!0});var ce=S(a);i=oe(ce,u[5]),ce.forEach(A),c=j(B),d=F(B,"P",{});var me=S(d);f=oe(me,o),me.forEach(A),B.forEach(A),Z.forEach(A),h=j(M),w=F(M,"DIV",{class:!0}),S(w).forEach(A),l=j(M),m=F(M,"DIV",{class:!0});var ee=S(m);$e(v.$$.fragment,ee),J=j(ee),U=F(ee,"P",{dir:!0,class:!0});var fe=S(U);W=oe(fe,u[4]),fe.forEach(A),ee.forEach(A),P=j(M),q=F(M,"DIV",{class:!0}),S(q).forEach(A),M.forEach(A),this.h()},h(){k(a,"dir","ltr"),k(r,"class",$="flex "+(u[1]?"flex-col":"flex-row")+" text-primary"),k(t,"class","flex flex-row items-center justify-center gap-2"),k(w,"class","w-8"),k(U,"dir","ltr"),k(U,"class","text-primary"),k(m,"class","flex flex-row gap-2 justify-center text-center"),k(q,"class","flex flex-row"),k(e,"class","flex flex-row items-center justify-center text-center bg-base-300 py-2 px-4 rounded-lg w-min text-nowrap")},m(D,M){Fe(D,e,M),b(e,t),he(s,t,null),b(t,n),b(t,r),b(r,a),b(a,i),b(r,c),b(r,d),b(d,f),b(e,h),b(e,w),b(e,l),b(e,m),he(v,m,null),b(m,J),b(m,U),b(U,W),b(e,P),b(e,q),N=!0},p(D,[M]){(!N||M&15)&&o!==(o=(D[1]?D[2]?te(D[0]):se(ae[D[0].getDay()],D[3]):`  (${D[2]?te(D[0]):se(ae[D[0].getDay()],D[3])})`)+"")&&Se(f,o),(!N||M&2&&$!==($="flex "+(D[1]?"flex-col":"flex-row")+" text-primary"))&&k(r,"class",$)},i(D){N||(Ie(s.$$.fragment,D),Ie(v.$$.fragment,D),N=!0)},o(D){De(s.$$.fragment,D),De(v.$$.fragment,D),N=!1},d(D){D&&A(e),ve(s),ve(v)}}}function nt(u,e,t){let s;Oe(u,at,d=>t(3,s=d));let{date:n}=e,{dayVertical:r=!0}=e,{showTodayAndTommrow:a=!1}=e;const i=ye(n,"HH:mm"),c=ye(n,"dd-MM-yyyy");return u.$$set=d=>{"date"in d&&t(0,n=d.date),"dayVertical"in d&&t(1,r=d.dayVertical),"showTodayAndTommrow"in d&&t(2,a=d.showTodayAndTommrow)},[n,r,a,s,i,c]}class ft extends Je{constructor(e){super(),xe(this,e,nt,rt,_e,{date:0,dayVertical:1,showTodayAndTommrow:2})}}function Ue({worker:u,booking:e,timeToOrderOn1970Format:t,oldBooking:s,recurrenceSkipDate:n,defaultWork:r,defaultTakenHoures:a,defaultForbbidenTimes:i,isUpdate:c=!1,allowAllDay:d=!1}){if(!u)return!1;if(!d&&u.closeScheduleOnHolidays&&He(u,e.bookingDate))return H.error("Holiday is a free day for this worker -> don't generate times"),!1;if(!d&&u.isClosingDate(e.bookingDate))return H.error("This day is closing by the worker"),!1;t=ue(t),d&&(r=[Ee("00:00"),Ee("23:59")]);const o=G(e.bookingDate);console.log("defaultWork",r),console.log("shifts",we(u.shiftsFor({day:e.bookingDate}))),console.log(u.shiftsFor({day:e.bookingDate}));const f=r??we(u.shiftsFor({day:e.bookingDate})),$=a??We({worker:u,bookingDate:o,isUpdate:c,workerAction:d,oldBooking:s,recurrenceSkipDate:n});let h=i??$;console.log("bookingDate",o),console.log($),r||f.sort(),i||h.sort(),console.log("333333333333333333333333333333333333333333"),h=Pe(h,t);const w=Ne.fromTreatmentsMap(e.treatments),l=Array.from({length:w.times.keys.length},(m,v)=>0);console.log(w),console.log("work",f);for(let m=0;m<f.length;m+=2){console.log("Inside for");let v=f[m];const J=f[m+1];if(v>t)break;if(J<=t)continue;if(v=t,ke(v,new Ve({minutes:w.totalMinutes}))>J&&!je(J,e))return T.GI().error=g.endOfWork,console.log("11111111"),!1;const U=Re(e,v),W=ze(l,U,h),P=W===0;return console.log("timeSegments",U),console.log("minutesToJump",W),!P&&Le(e,t,o,u,U)?(T.GI().error=g.currentlyOrderingForTime,console.log("2222"),!1):(console.log("2222111111111111111111"),P)}return console.log("1111222222222222222222222wwwwwwwwwwwwwww"),!1}class it extends qe{async getUpdatedBookingDate({transaction:e,bookingToUpdate:t,dateForRecurrenceChild:s,checkForUpdate:n=!1}){let r;if(await super.transactionGet(e,`${de}/${t.customerId}/${p}/${I}/${Ke}`,t.recurrenceEvent!=null?be:R(t.bookingDate)).then(a=>{if(a.exists()&&a.data()!=null){const i=a.data()[t.bookingId];i!=null&&(r=Qe.fromJson(i,t.bookingId))}}),r!=null)return this.checkBookingDateValidity({updatedBooking:r,dateForRecurrenceChild:s,checkForUpdate:n,bookingToUpdate:t})?r:void 0;T.GI().details="",T.GI().error=g.workerDeleteTheBookingMeanwhile}checkBookingDateValidity({updatedBooking:e,dateForRecurrenceChild:t,checkForUpdate:s,bookingToUpdate:n}){if(e.recurrenceEvent!=null){if(t!=null&&e.recurrenceEvent.exceptionDates.has(Xe(t)))return T.GI().details="",T.GI().error=g.workerUpdatedTheBookingMeanwhile,!1}else if(!s&&e.bookingDate.getTime()!=n.bookingDate.getTime())return T.GI().details="",T.GI().error=g.workerUpdatedTheBookingMeanwhile,!1;return!0}async addBooking({booking:e,worker:t,needPayInAdvance:s,afterPayment:n,customerData:r}){const a=`${y}/${z.currentBusinesssId}/${E}`,i=G(e.bookingDate),c=re(e.bookingDate),d=R(e.bookingDate),o={};e.recurrenceEvent==null?e.bookingWorkTimes.forEach((l,m)=>{s?o[`duringPaymentBookingsTime.${i}.${m}`]=[Ye.fromDate(ke(new Date,Ze)),l]:(o[`bookingsTimes.${i}.${m}`]=l,n&&(o[`duringPaymentBookingsTime.${i}.${m}`]=null))}):e.bookingsEventsAsJson.forEach((l,m)=>{o[i]??(o[i]={}),o[i][m]=l});const f={};e.bookingsEventsAsJson.forEach((l,m)=>{f[c]??(f[c]={}),f[c][m]=l});const $=r.toJson();let h=1;e.recurrenceEvent!=null&&(h=e.recurrenceEvent.accurances??1e4),$.amoutOfBookings=Be(h);const w=async l=>{e.notificationType=st({booking:e,worker:t});let m,v=!1;if(!n){if(m=await this.getWorkerFromTransactionRepo({transaction:l,workerId:e.workerId}),m===void 0)return!1;if(v=Ue({worker:m,booking:e,timeToOrderOn1970Format:ue(e.bookingDate)}),!v)return T.GI().error===g.currentlyOrderingForTime?H.error("Cant order the booking to this time currently someone pay for it"):(T.GI().error=g.takenBooking,H.error("Cant order the booking to this time already taken")),!1}return e.addToClientAt&&this.transactionSetAsMap({transaction:l,path:`${de}/${e.customerId}/${p}`,docId:I,data:{clientAt:{[e.buisnessId]:{[e.workerId]:""}}}}),e.recurrenceEvent===void 0&&(console.log("timesData",o),this.transactionUpdateMultipleFieldsAsMap({transaction:l,path:`${a}/${t.id}/${p}`,docId:I,data:o})),s||(e.recurrenceEvent===void 0&&(console.log("bookingsEventsData",f),this.transactionSetAsMap({transaction:l,path:`${a}/${t.id}/${p}/${I}/${L}`,docId:d,data:f})),console.log("4444444444"),this.transactionSetAsMap({transaction:l,path:`${a}/${t.id}/${p}/${I}/${C}`,docId:i,data:{[e.bookingId]:e.toJson()}}),console.log("33333333333"),this.updateUserBooking({transaction:l,booking:e,isSetMerge:!0,command:O.increment,data:{[e.bookingId]:e.toJson()}}),console.log("wwwwwwwwwwwwwwwwwww"),this.transactionSetAsMap({transaction:l,path:`${y}/${e.buisnessId}/${E}/${e.workerId}/${p}`,docId:K,data:{data:{[r.customerUuid]:$}}}),console.log("rr")),!0};return await this.runTransaction(w).then(l=>{if(l)e.recurrenceEvent==null&&!s&&this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!0,types:e.typesOfEvents});else return;return e})}async deleteBooking({booking:e,deleteAllBooking:t,customerData:s,cancelDate:n,deleteFromWorker:r,deleteFromUser:a}){const i=G(e.bookingDate),c=re(e.bookingDate),d=R(e.bookingDate),o=`${y}/${z.currentBusinesssId}/${E}`,f={};e.bookingWorkTimes.forEach((l,m)=>{f[`bookingsTimes.${i}.${m}`]=null});const $={};e.bookingsEventsAsEvents.forEach((l,m)=>{$[`${c}.${m}`]=null});const h=this.toFormatedCustomerData({customerData:s,amountOfBookingsCommand:O.decrement}),w=async l=>await this.getUpdatedBookingDate({transaction:l,bookingToUpdate:e})==null?!1:(e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist,e.userDeleted||this.transactionUpdateMultipleFieldsAsMap({transaction:l,path:`${y}/${z.currentBusinesssId}/${E}/${e.workerId}/${p}`,docId:K,data:h}),this.transactionUpdateMultipleFieldsAsMap({transaction:l,path:`${o}/${e.workerId}/${p}`,docId:I,data:f}),console.log("deleteFromWorker",r),r&&(console.log("bookingsEventsData",$),this.transactionUpdateMultipleFieldsAsMap({transaction:l,path:`${o}/${e.workerId}/${p}/${I}/${L}`,docId:d,data:$}),console.log("deleteAllBooking",t),t?this.transactionUpdateAsMap({transaction:l,path:`${o}/${e.workerId}/${p}/${I}/${C}`,docId:i,fieldName:e.bookingId}):this.transactionUpdateAsMap({transaction:l,path:`${o}/${e.workerId}/${p}/${I}/${C}`,docId:i,fieldName:`${e.bookingId}.cancelDate`,value:Q(n)})),await this.updateUserBooking({booking:e,transaction:l,command:a?O.decrement:void 0,data:a?{[e.bookingId]:null}:{[`${e.bookingId}.workerDeleted`]:!0}}),!0);return await this.runTransaction(w).then(l=>l?(this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!1,types:e.typesOfEvents}),[e]):null)}async deleteBookingOnlyFromUser({booking:e}){const t=async s=>await this.getUpdatedBookingDate({transaction:s,bookingToUpdate:e})==null?!1:(e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist,await this.updateUserBooking({booking:e,transaction:s,command:O.decrement,data:{[e.bookingId]:null}}),!0);return await this.runTransaction(t)}async updateBooking({oldBooking:e,newBooking:t,oldBookingDateForReccurence:s,newBookingCustomerData:n,oldBookingCustomerData:r}){const a=G(e.bookingDate),i=G(t.bookingDate),c=async d=>{if(await this.getUpdatedBookingDate({transaction:d,bookingToUpdate:e,dateForRecurrenceChild:s})==null)return!1;e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist;const f=await this.getWorkerFromTransactionRepo({transaction:d,workerId:t.workerId}),$=e.bookingDate.getTime()===t.bookingDate.getTime()&&e.treatmentLength>t.treatmentLength;return Ue({worker:f,booking:t,timeToOrderOn1970Format:ue(t.bookingDate),oldBooking:e,recurrenceSkipDate:s,isUpdate:e.workerId===t.workerId,allowAllDay:$})?(this.updateBookingsEvents(d,e,t,s),this.updateBookingsTimes(d,e,t,i,a,s),n&&r&&this.updateWorkerCustomerData({transaction:d,oldBooking:e,newBooking:t,newBookingCustomerData:n,oldBookingCustomerData:r}),this.updateWorkerBookingsObjects(d,e,t,i,a,s),this.updateUserBookingsObject({oldBooking:e,transaction:d,newBooking:t,oldBookingDateForReccurence:s}),!0):(T.GI().error===g.currentlyOrderingForTime?H.debug("Cant order the booking to this time currently someone pay for it"):(T.GI().error=g.takenBooking,H.debug("Cant order the booking to this time already taken")),!1)};return this.runTransaction(c).then(d=>{if(d)if(e.workerId!==t.workerId)this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!1,types:e.typesOfEvents}),this.realTimeEventsCounterHandler({workerId:t.workerId,businessId:t.buisnessId,increment:!0,types:t.typesOfEvents});else{const o=new Map;e.needCancel&&!t.needCancel&&o.set(le.needCancel,1),e.status===X.waiting&&t.status!==X.waiting&&o.set(le.onHold,1),e.status!==X.waiting&&t.status===X.waiting&&o.set(le.onHold,-1),Object.keys(o).length>0&&this.realTimeEventsCounterHandler({workerId:t.workerId,businessId:t.buisnessId,increment:!1,types:o})}return d})}updateWorkerCustomerData({transaction:e,oldBooking:t,newBooking:s,newBookingCustomerData:n,oldBookingCustomerData:r}){if(s.workerId!==t.workerId){const i=this.toFormatedCustomerData({customerData:n,amountOfBookingsCommand:O.increment,useUserFirstBookingsDate:!0,saveExtraData:!0});this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${z.currentBusinesssId}/${E}/${s.workerId}/${p}`,docId:K,data:i});const c=this.toFormatedCustomerData({customerData:r,amountOfBookingsCommand:O.decrement});this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${z.currentBusinesssId}/${E}/${t.workerId}/${p}`,docId:K,data:c});return}const a={};n.lastBookingsDate!=null&&(a[`data.${n.customerUuid}.lastBookingsDate`]=Q(n.lastBookingsDate)),n.firstBookingsDate!=null&&(a[`data.${n.customerUuid}.firstBookingsDate`]=Q(n.firstBookingsDate)),n.userFirstBookingsDate!=null&&(a[`data.${n.customerUuid}.userFirstBookingsDate`]=Q(n.userFirstBookingsDate)),console.log(a),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${z.currentBusinesssId}/${E}/${s.workerId}/${p}`,docId:K,data:a})}updateBookingsEvents(e,t,s,n){const r=`${y}/${s.buisnessId}/${E}`,a=re(s.bookingDate),i=R(s.bookingDate),c=re(t.bookingDate),d=R(t.bookingDate),o={};if(t.recurrenceEvent!=null&&n!=null){const $={};t.bookingsEventsAsJson.forEach((h,w)=>{$[`${G(t.bookingDate)}.${h}.RE.EDA.${G(n)}`]=""}),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${p}`,docId:et,data:$}),s.bookingsEventsAsJson.forEach((h,w)=>{o[a]||(o[a]={}),o[a][w]=h}),this.transactionSetAsMap({transaction:e,path:`${r}/${s.workerId}/${p}/${I}/${L}`,docId:i,data:o});return}let f={};t.bookingsEventsAsJson.forEach(($,h)=>{f[`${c}.${h}`]=null}),t.workerId!==s.workerId||d!==i?(this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${p}/${I}/${L}`,docId:d,data:f}),s.bookingsEventsAsJson.forEach(($,h)=>{o[a]?o[a][h]=$:o[a]={[h]:$}}),this.transactionSetAsMap({transaction:e,path:`${r}/${s.workerId}/${p}/${I}/${L}`,docId:i,data:o})):(s.bookingsEventsAsJson.forEach(($,h)=>{o[`${a}.${h}`]=$}),f={...f,...o},this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${p}/${I}/${L}`,docId:d,data:f}))}updateBookingsTimes(e,t,s,n,r,a){const i={};if(s.bookingWorkTimes.forEach((d,o)=>{i[`bookingsTimes.${n}.${o}`]=d}),t.recurrenceEvent!=null&&a!=null){this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}`,docId:I,data:i});return}let c={};t.bookingWorkTimes.forEach((d,o)=>{c[`bookingsTimes.${r}.${o}`]=null}),t.workerId!=s.workerId?(this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${p}`,docId:I,data:c}),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}`,docId:I,data:i})):(c=Object.assign(c,i),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}`,docId:I,data:c}))}updateWorkerBookingsObjects(e,t,s,n,r,a){r!=n?(t.recurrenceEvent!=null&&a!=null?this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${p}/${I}/${C}`,docId:r,fieldName:`${t.bookingId}.RE.EDA.${G(a)}`,value:""}):this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${p}/${I}/${C}`,docId:r,fieldName:t.bookingId}),this.transactionSetAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}/${I}/${C}`,docId:n,data:{[s.bookingId]:s.toJson()}})):t.workerId!=s.workerId?(this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${p}/${I}/${C}`,docId:r,fieldName:t.bookingId}),this.transactionSetAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}/${I}/${C}`,docId:n,data:{[s.bookingId]:s.toJson()}})):(t.recurrenceEvent!=null&&a!=null&&this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${p}/${I}/${C}`,docId:r,fieldName:`${t.bookingId}.RE.EDA.${G(a)}`,value:""}),this.transactionUpdateAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${p}/${I}/${C}`,docId:n,fieldName:s.bookingId,value:s.toJson()}))}updateUserBookingsObject({oldBooking:e,newBooking:t,transaction:s,oldBookingDateForReccurence:n}){e.recurrenceEvent!=null?n!=null&&(this.updateUserBooking({transaction:s,booking:e,data:{[`${e.bookingId}.RE.EDA.${G(n)}`]:""}}),this.updateUserBooking({transaction:s,booking:t,command:O.increment,data:{[t.bookingId]:t.toJson()}})):e.customerId!==t.customerId||e.monthStr!==t.monthStr?(e.recurrenceEvent===null&&this.updateUserBooking({transaction:s,booking:e,command:O.decrement,data:{[e.bookingId]:null}}),this.updateUserBooking({transaction:s,booking:t,command:O.increment,data:{[t.bookingId]:t.toJson()},isSetMerge:!0})):this.updateUserBooking({transaction:s,booking:t,data:{[t.bookingId]:t.toJson()}})}async updateUserBooking({booking:e,data:t,command:s,isSetMerge:n=!1,transaction:r}){if(e.userDeleted)return!1;const a=e.recurrenceEvent?be:R(e.bookingDate),i={};s!==void 0&&(i[`bookingsPreviews.${a}.bookingCount`]=s),i[`bookingsPreviews.${a}.lastUpdateTime`]=Q(new Date);let c=tt.GI().userBookingsPathByBooking(e);return r!=null?(n?this.transactionSetAsMap({transaction:r,path:c,docId:a,data:t}):this.transactionUpdateMultipleFieldsAsMap({transaction:r,path:c,docId:a,data:t}),console.log("previewData",i),this.transactionUpdateMultipleFieldsAsMap({transaction:r,path:`${de}/${e.customerId}/${p}`,docId:I,data:i}),!0):n?await this.setAsMapWithMergeRepo({path:c,docId:a,valueAsJson:t}):await this.updateMultipleFieldsInsideDocAsMapRepo({path:c,docId:a,data:t})}}const Y=class Y{constructor(){ne(this,"bookingRepo",new it)}static GI(){return Y._singleton}async addBooking({booking:e,worker:t,clientNote:s="",needPayInAdvance:n=!1,filledBooking:r=!1}){if(!x.GI().isConnected){T.GI().error=g.notLogedIn;return}if(console.log("22222222222222222"),e.treatments.size===0){T.GI().error=g.noTreatment;return}r||await e.copyDataToOrder({worker:t,user:x.GI().user,needToHoldOn:Te(e.bookingDate,t),business:Me.GI().business,clientNoteText:s}),console.log("eeeeeeeeeeeeeeeeeeee");const a=x.GI().user.customerDataFromBooking({booking:e});return await this.bookingRepo.addBooking({booking:e,needPayInAdvance:n,worker:t,afterPayment:!1,customerData:a}).then(async i=>(console.log(i),i))}async deleteBookingOnlyFromUserDoc({booking:e,deleteFromPassed:t}){return await this.bookingRepo.deleteBookingOnlyFromUser({booking:e}).then(async s=>s)}async deleteBooking({booking:e,worker:t}){if(!x.GI().isConnected)return T.GI().error=g.notLogedIn,null;const s=new Date,n=e.status===X.waiting,r=x.GI().user.customerDataFromBooking({booking:e,needDelete:!0});console.log("booking.isPassed",e.isPassed);const a=await this.bookingRepo.deleteBooking({booking:e,deleteAllBooking:n,cancelDate:s,customerData:r,deleteFromWorker:!e.isPassed,deleteFromUser:!0});return a?(a.forEach(i=>{}),a):null}async updateBooking({newBooking:e,oldBooking:t,newWorker:s,oldWorker:n,forceUpdate:r=!1,oldBookingDateForReccurence:a,noteText:i,newClientNote:c="",keepRecurrence:d=!1,workerAction:o=!1}){if(!r&&e.isTheSameAs({booking:t,note:o?i:t.note,customerId:t.customerId}))return H.debug("Don't need to access the database, no changes in the booking"),!0;e.updateBookingByBooking({oldBooking:t,worker:s,needToHoldOn:Te(e.bookingDate,s),business:Me.GI().business,newClientNote:c,keepRecurrence:d});const f=t.customerId===e.customerId&&e.workerId===t.workerId,$=f?e.bookingDate:void 0;t.bookingDate.getTime()+t.totalMinutes*60*1e3<Date.now();const h=f?t.bookingDate:void 0,w=x.GI().user.customerDataFromBooking({booking:t,needDelete:!0,initDate:$}),l=x.GI().user.customerDataFromBooking({booking:e,exclude:h});return await this.bookingRepo.updateBooking({oldBooking:t,newBooking:e,oldBookingCustomerData:w,newBookingCustomerData:l,oldBookingDateForReccurence:a}).then(async v=>(v&&console.log("value",v),v))}};ne(Y,"_singleton",new Y);let Ae=Y;export{Ae as B,ft as D};
