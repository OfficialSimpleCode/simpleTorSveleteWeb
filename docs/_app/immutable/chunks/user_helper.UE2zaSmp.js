var ve=Object.defineProperty;var Te=(D,e,t)=>e in D?ve(D,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):D[e]=t;var g=(D,e,t)=>(Te(D,typeof e!="symbol"?e+"":e,t),t);import{t as P,F as Me,H as Ue,y as W,I as ne,J as oe,K as M,N as ce,O as Re,P as ke,Q as Ce,R as Q,S as K,X as Pe,s as b,E as A,Y as Ne,Z as Oe,_ as Fe,G as ge,u as R,a as l,c as m,$ as Se,a0 as he,j as F,a1 as Ge,a2 as be,a3 as V,T as de,a4 as xe,a5 as We,a6 as k,a7 as te,x as q,e as y,f as N,a8 as E,a9 as x,aa as j,ab as Y,ac as C,ad as v,ae as X,af as je,ag as le,ah as Je,ai as pe,aj as Ae,ak as ue,al as Le,am as Ve,an as He,ao as ze,ap as se,aq as _e,ar as Ke,as as Ze,at as qe,au as Ye,av as Qe,aw as fe,ax as Xe,ay as Be,az as et,aA as tt,m as o,B as U,aB as st,aC as $e,aD as at,V as rt,aE as ae,aF as re,aG as ie,A as it,aH as S,aI as nt,aJ as ot,l as H,aK as Ie,aL as me,z as dt,aM as ut,aN as De,p as lt,aO as ct}from"./business_initializer.RqQi4dFb.js";import"./runtime.NUMuemaG.js";import{V as we}from"./verification_helper.CYLZskaY.js";function ht(D){return D===null||D===""||/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(D)?null:P("invalidEmail")}function yt(D){return D==null?null:D.trim().length>Me?P("tooLongNote"):""}function Et(D,e={}){const t=e.withoutTranslate||!1;if(D===null)return D;if(D.includes("&&"))return t?"":P("illegalName")+" - &&";if(D.includes("~"))return t?"":P("illegalName")+" - ~";if(D==="guest")return t?"":P("illegalName")+" - guest";if(D.length>30||D.length<2)return t?"":P("illegalName");if(D.length>15&&!D.includes(" "))return t?"":P("illegalName");for(let s=0;s<Math.min(D.length,2);s++)if(D[s]===" ")return t?"":P("illegalName");return null}function ye({worker:D,booking:e,timeToOrderOn1970Format:t,oldBooking:s,recurrenceSkipDate:a,defaultWork:r,defaultTakenHoures:i,defaultForbbidenTimes:n,isUpdate:c=!1,allowAllDay:u=!1}){if(!D)return!1;if(!u&&D.closeScheduleOnHolidays&&Ue(D,e.bookingDate))return W.error("Holiday is a free day for this worker -> don't generate times"),!1;if(!u&&D.isClosingDate(e.bookingDate))return W.error("This day is closing by the worker"),!1;t=ne(t),u&&(r=[oe("00:00"),oe("23:59")]);const d=M(e.bookingDate);console.log("defaultWork",r),console.log("shifts",ce(D.shiftsFor({day:e.bookingDate}))),console.log(D.shiftsFor({day:e.bookingDate}));const $=r??ce(D.shiftsFor({day:e.bookingDate})),f=i??Re({worker:D,bookingDate:d,isUpdate:c,workerAction:u,oldBooking:s,recurrenceSkipDate:a});let I=n??f;console.log("bookingDate",d),console.log(f),r||$.sort(),n||I.sort(),console.log("333333333333333333333333333333333333333333"),I=ke(I,t);const h=Ce.fromTreatmentsMap(e.treatments),p=Array.from({length:h.times.keys.length},(w,G)=>0);console.log(h),console.log("work",$);for(let w=0;w<$.length;w+=2){console.log("Inside for");let G=$[w];const T=$[w+1];if(G>t)break;if(T<=t)continue;if(G=t,Q(G,new K({minutes:h.totalMinutes}))>T&&!Pe(T,e))return b.GI().error=A.endOfWork,console.log("11111111"),!1;const O=Ne(e,G),J=Oe(p,O,I),L=J===0;return console.log("timeSegments",O),console.log("minutesToJump",J),!L&&Fe(e,t,d,D,O)?(b.GI().error=A.currentlyOrderingForTime,console.log("2222"),!1):(console.log("2222111111111111111111"),L)}return console.log("1111222222222222222222222wwwwwwwwwwwwwww"),!1}class pt extends ge{async getUpdatedBookingDate({transaction:e,bookingToUpdate:t,dateForRecurrenceChild:s,checkForUpdate:a=!1}){let r;if(await super.transactionGet(e,`${R}/${t.customerId}/${l}/${m}/${Se}`,t.recurrenceEvent!=null?he:F(t.bookingDate)).then(i=>{if(i.exists()&&i.data()!=null){const n=i.data()[t.bookingId];n!=null&&(r=Ge.fromJson(n,t.bookingId))}}),r!=null)return this.checkBookingDateValidity({updatedBooking:r,dateForRecurrenceChild:s,checkForUpdate:a,bookingToUpdate:t})?r:void 0;b.GI().details="",b.GI().error=A.workerDeleteTheBookingMeanwhile}checkBookingDateValidity({updatedBooking:e,dateForRecurrenceChild:t,checkForUpdate:s,bookingToUpdate:a}){if(e.recurrenceEvent!=null){if(t!=null&&e.recurrenceEvent.exceptionDates.has(be(t)))return b.GI().details="",b.GI().error=A.workerUpdatedTheBookingMeanwhile,!1}else if(!s&&e.bookingDate.getTime()!=a.bookingDate.getTime())return b.GI().details="",b.GI().error=A.workerUpdatedTheBookingMeanwhile,!1;return!0}async addBooking({booking:e,worker:t,needPayInAdvance:s,afterPayment:a,customerData:r}){const i=`${y}/${N.currentBusinesssId}/${E}`,n=M(e.bookingDate),c=V(e.bookingDate),u=F(e.bookingDate),d={};e.recurrenceEvent==null?e.bookingWorkTimes.forEach((p,w)=>{s?d[`duringPaymentBookingsTime.${n}.${w}`]=[de.fromDate(Q(new Date,xe)),p]:(d[`bookingsTimes.${n}.${w}`]=p,a&&(d[`duringPaymentBookingsTime.${n}.${w}`]=null))}):e.bookingsEventsAsJson.forEach((p,w)=>{d[n]??(d[n]={}),d[n][w]=p});const $={};e.bookingsEventsAsJson.forEach((p,w)=>{$[c]??($[c]={}),$[c][w]=p});const f=r.toJson();let I=1;e.recurrenceEvent!=null&&(I=e.recurrenceEvent.accurances??1e4),f.amoutOfBookings=We(I);const h=async p=>{e.notificationType=je({booking:e,worker:t});let w,G=!1;if(!a){if(w=await this.getWorkerFromTransactionRepo({transaction:p,workerId:e.workerId}),w===void 0)return!1;if(G=ye({worker:w,booking:e,timeToOrderOn1970Format:ne(e.bookingDate)}),!G)return b.GI().error===A.currentlyOrderingForTime?W.error("Cant order the booking to this time currently someone pay for it"):(b.GI().error=A.takenBooking,W.error("Cant order the booking to this time already taken")),!1}return e.addToClientAt&&this.transactionSetAsMap({transaction:p,path:`${R}/${e.customerId}/${l}`,docId:m,data:{clientAt:{[e.buisnessId]:{[e.workerId]:""}}}}),e.recurrenceEvent===void 0&&(console.log("timesData",d),this.transactionUpdateMultipleFieldsAsMap({transaction:p,path:`${i}/${t.id}/${l}`,docId:m,data:d})),s||(e.recurrenceEvent===void 0&&(console.log("bookingsEventsData",$),this.transactionSetAsMap({transaction:p,path:`${i}/${t.id}/${l}/${m}/${C}`,docId:u,data:$})),console.log("4444444444"),this.transactionSetAsMap({transaction:p,path:`${i}/${t.id}/${l}/${m}/${v}`,docId:n,data:{[e.bookingId]:e.toJson()}}),console.log("33333333333"),this.updateUserBooking({transaction:p,booking:e,isSetMerge:!0,command:k.increment,data:{[e.bookingId]:e.toJson()}}),console.log("wwwwwwwwwwwwwwwwwww"),this.transactionSetAsMap({transaction:p,path:`${y}/${e.buisnessId}/${E}/${e.workerId}/${l}`,docId:x,data:{data:{[r.customerUuid]:f}}}),console.log("rr")),!0};return await this.runTransaction(h).then(p=>{if(p)e.recurrenceEvent==null&&!s&&this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!0,types:e.typesOfEvents});else return;return e})}async deleteBooking({booking:e,deleteAllBooking:t,customerData:s,cancelDate:a,deleteFromWorker:r,deleteFromUser:i}){const n=M(e.bookingDate),c=V(e.bookingDate),u=F(e.bookingDate),d=`${y}/${N.currentBusinesssId}/${E}`,$={};e.bookingWorkTimes.forEach((p,w)=>{$[`bookingsTimes.${n}.${w}`]=null});const f={};e.bookingsEventsAsEvents.forEach((p,w)=>{f[`${c}.${w}`]=null});const I=this.toFormatedCustomerData({customerData:s,amountOfBookingsCommand:k.decrement}),h=async p=>await this.getUpdatedBookingDate({transaction:p,bookingToUpdate:e})==null?!1:(e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist,e.userDeleted||this.transactionUpdateMultipleFieldsAsMap({transaction:p,path:`${y}/${N.currentBusinesssId}/${E}/${e.workerId}/${l}`,docId:x,data:I}),this.transactionUpdateMultipleFieldsAsMap({transaction:p,path:`${d}/${e.workerId}/${l}`,docId:m,data:$}),console.log("deleteFromWorker",r),r&&(console.log("bookingsEventsData",f),this.transactionUpdateMultipleFieldsAsMap({transaction:p,path:`${d}/${e.workerId}/${l}/${m}/${C}`,docId:u,data:f}),console.log("deleteAllBooking",t),t?this.transactionUpdateAsMap({transaction:p,path:`${d}/${e.workerId}/${l}/${m}/${v}`,docId:n,fieldName:e.bookingId}):this.transactionUpdateAsMap({transaction:p,path:`${d}/${e.workerId}/${l}/${m}/${v}`,docId:n,fieldName:`${e.bookingId}.cancelDate`,value:j(a)})),await this.updateUserBooking({booking:e,transaction:p,command:i?k.decrement:void 0,data:i?{[e.bookingId]:null}:{[`${e.bookingId}.workerDeleted`]:!0}}),!0);return await this.runTransaction(h).then(p=>p?(this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!1,types:e.typesOfEvents}),[e]):null)}async deleteBookingOnlyFromUser({booking:e}){const t=async s=>await this.getUpdatedBookingDate({transaction:s,bookingToUpdate:e})==null?!1:(e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist,await this.updateUserBooking({booking:e,transaction:s,command:k.decrement,data:{[e.bookingId]:null}}),!0);return await this.runTransaction(t)}async updateBooking({oldBooking:e,newBooking:t,oldBookingDateForReccurence:s,newBookingCustomerData:a,oldBookingCustomerData:r}){const i=M(e.bookingDate),n=M(t.bookingDate),c=async u=>{if(await this.getUpdatedBookingDate({transaction:u,bookingToUpdate:e,dateForRecurrenceChild:s})==null)return!1;e.bookingDate=e.bookingDate,e.isUserExist=e.isUserExist;const $=await this.getWorkerFromTransactionRepo({transaction:u,workerId:t.workerId}),f=e.bookingDate.getTime()===t.bookingDate.getTime()&&e.treatmentLength>t.treatmentLength;return ye({worker:$,booking:t,timeToOrderOn1970Format:ne(t.bookingDate),oldBooking:e,recurrenceSkipDate:s,isUpdate:e.workerId===t.workerId,allowAllDay:f})?(this.updateBookingsEvents(u,e,t,s),this.updateBookingsTimes(u,e,t,n,i,s),a&&r&&this.updateWorkerCustomerData({transaction:u,oldBooking:e,newBooking:t,newBookingCustomerData:a,oldBookingCustomerData:r}),this.updateWorkerBookingsObjects(u,e,t,n,i,s),this.updateUserBookingsObject({oldBooking:e,transaction:u,newBooking:t,oldBookingDateForReccurence:s}),!0):(b.GI().error===A.currentlyOrderingForTime?W.debug("Cant order the booking to this time currently someone pay for it"):(b.GI().error=A.takenBooking,W.debug("Cant order the booking to this time already taken")),!1)};return this.runTransaction(c).then(u=>{if(u)if(e.workerId!==t.workerId)this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:!1,types:e.typesOfEvents}),this.realTimeEventsCounterHandler({workerId:t.workerId,businessId:t.buisnessId,increment:!0,types:t.typesOfEvents});else{const d=new Map;e.needCancel&&!t.needCancel&&d.set(te.needCancel,1),e.status===q.waiting&&t.status!==q.waiting&&d.set(te.onHold,1),e.status!==q.waiting&&t.status===q.waiting&&d.set(te.onHold,-1),Object.keys(d).length>0&&this.realTimeEventsCounterHandler({workerId:t.workerId,businessId:t.buisnessId,increment:!1,types:d})}return u})}updateWorkerCustomerData({transaction:e,oldBooking:t,newBooking:s,newBookingCustomerData:a,oldBookingCustomerData:r}){if(s.workerId!==t.workerId){const n=this.toFormatedCustomerData({customerData:a,amountOfBookingsCommand:k.increment,useUserFirstBookingsDate:!0,saveExtraData:!0});this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${N.currentBusinesssId}/${E}/${s.workerId}/${l}`,docId:x,data:n});const c=this.toFormatedCustomerData({customerData:r,amountOfBookingsCommand:k.decrement});this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${N.currentBusinesssId}/${E}/${t.workerId}/${l}`,docId:x,data:c});return}const i={};a.lastBookingsDate!=null&&(i[`data.${a.customerUuid}.lastBookingsDate`]=j(a.lastBookingsDate)),a.firstBookingsDate!=null&&(i[`data.${a.customerUuid}.firstBookingsDate`]=j(a.firstBookingsDate)),a.userFirstBookingsDate!=null&&(i[`data.${a.customerUuid}.userFirstBookingsDate`]=j(a.userFirstBookingsDate)),console.log(i),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${N.currentBusinesssId}/${E}/${s.workerId}/${l}`,docId:x,data:i})}updateBookingsEvents(e,t,s,a){const r=`${y}/${s.buisnessId}/${E}`,i=V(s.bookingDate),n=F(s.bookingDate),c=V(t.bookingDate),u=F(t.bookingDate),d={};if(t.recurrenceEvent!=null&&a!=null){const f={};t.bookingsEventsAsJson.forEach((I,h)=>{f[`${M(t.bookingDate)}.${I}.RE.EDA.${M(a)}`]=""}),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${l}`,docId:Y,data:f}),s.bookingsEventsAsJson.forEach((I,h)=>{d[i]||(d[i]={}),d[i][h]=I}),this.transactionSetAsMap({transaction:e,path:`${r}/${s.workerId}/${l}/${m}/${C}`,docId:n,data:d});return}let $={};t.bookingsEventsAsJson.forEach((f,I)=>{$[`${c}.${I}`]=null}),t.workerId!==s.workerId||u!==n?(this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${l}/${m}/${C}`,docId:u,data:$}),s.bookingsEventsAsJson.forEach((f,I)=>{d[i]?d[i][I]=f:d[i]={[I]:f}}),this.transactionSetAsMap({transaction:e,path:`${r}/${s.workerId}/${l}/${m}/${C}`,docId:n,data:d})):(s.bookingsEventsAsJson.forEach((f,I)=>{d[`${i}.${I}`]=f}),$={...$,...d},this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${r}/${t.workerId}/${l}/${m}/${C}`,docId:u,data:$}))}updateBookingsTimes(e,t,s,a,r,i){const n={};if(s.bookingWorkTimes.forEach((u,d)=>{n[`bookingsTimes.${a}.${d}`]=u}),t.recurrenceEvent!=null&&i!=null){this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}`,docId:m,data:n});return}let c={};t.bookingWorkTimes.forEach((u,d)=>{c[`bookingsTimes.${r}.${d}`]=null}),t.workerId!=s.workerId?(this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${l}`,docId:m,data:c}),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}`,docId:m,data:n})):(c=Object.assign(c,n),this.transactionUpdateMultipleFieldsAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}`,docId:m,data:c}))}updateWorkerBookingsObjects(e,t,s,a,r,i){r!=a?(t.recurrenceEvent!=null&&i!=null?this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${l}/${m}/${v}`,docId:r,fieldName:`${t.bookingId}.RE.EDA.${M(i)}`,value:""}):this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${l}/${m}/${v}`,docId:r,fieldName:t.bookingId}),this.transactionSetAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}/${m}/${v}`,docId:a,data:{[s.bookingId]:s.toJson()}})):t.workerId!=s.workerId?(this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${l}/${m}/${v}`,docId:r,fieldName:t.bookingId}),this.transactionSetAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}/${m}/${v}`,docId:a,data:{[s.bookingId]:s.toJson()}})):(t.recurrenceEvent!=null&&i!=null&&this.transactionUpdateAsMap({transaction:e,path:`${y}/${t.buisnessId}/${E}/${t.workerId}/${l}/${m}/${v}`,docId:r,fieldName:`${t.bookingId}.RE.EDA.${M(i)}`,value:""}),this.transactionUpdateAsMap({transaction:e,path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}/${m}/${v}`,docId:a,fieldName:s.bookingId,value:s.toJson()}))}updateUserBookingsObject({oldBooking:e,newBooking:t,transaction:s,oldBookingDateForReccurence:a}){e.recurrenceEvent!=null?a!=null&&(this.updateUserBooking({transaction:s,booking:e,data:{[`${e.bookingId}.RE.EDA.${M(a)}`]:""}}),this.updateUserBooking({transaction:s,booking:t,command:k.increment,data:{[t.bookingId]:t.toJson()}})):e.customerId!==t.customerId||e.monthStr!==t.monthStr?(e.recurrenceEvent===null&&this.updateUserBooking({transaction:s,booking:e,command:k.decrement,data:{[e.bookingId]:null}}),this.updateUserBooking({transaction:s,booking:t,command:k.increment,data:{[t.bookingId]:t.toJson()},isSetMerge:!0})):this.updateUserBooking({transaction:s,booking:t,data:{[t.bookingId]:t.toJson()}})}async updateUserBooking({booking:e,data:t,command:s,isSetMerge:a=!1,transaction:r}){if(e.userDeleted)return!1;const i=e.recurrenceEvent?he:F(e.bookingDate),n={};s!==void 0&&(n[`bookingsPreviews.${i}.bookingCount`]=s),n[`bookingsPreviews.${i}.lastUpdateTime`]=j(new Date);let c=X.GI().userBookingsPathByBooking(e);return r!=null?(a?this.transactionSetAsMap({transaction:r,path:c,docId:i,data:t}):this.transactionUpdateMultipleFieldsAsMap({transaction:r,path:c,docId:i,data:t}),console.log("previewData",n),this.transactionUpdateMultipleFieldsAsMap({transaction:r,path:`${R}/${e.customerId}/${l}`,docId:m,data:n}),!0):a?await this.setAsMapWithMergeRepo({path:c,docId:i,valueAsJson:t}):await this.updateMultipleFieldsInsideDocAsMapRepo({path:c,docId:i,data:t})}async updateFieldsInBooking({booking:e,data:t,eventValue:s,updateUser:a=!0,changeInEvents:r=!1,incrementCounters:i=!0,counterType:n,eventFieldName:c}){const u=async d=>{const $=await this.getUpdatedBookingDate({transaction:d,bookingToUpdate:e});if($==null)return!1;e.bookingDate=$.bookingDate,e.isUserExist=$.isUserExist;const f=`${y}/${e.buisnessId}/${E}`;if(r&&c!==null){const h=V(e.bookingDate),p=F(e.bookingDate),w={};e.bookingsEventsAsJson.forEach((G,T)=>{w[`${h}.${G}.${c}`]=s}),this.transactionUpdateMultipleFieldsAsMap({transaction:d,path:`${f}/${e.workerId}/${l}/${m}/${C}`,docId:p,data:w})}const I={};return Object.entries(t).forEach(([h,p])=>{I[e.isMultiRef?`${le(e.bookingDate)}.users.${e.bookingId}.${h}`:`${e.bookingId}.${h}`]=p}),this.transactionUpdateMultipleFieldsAsMap({transaction:d,path:`${f}/${e.workerId}/${l}/${m}/${v}`,docId:M(e.bookingDate),data:I}),!0};return await this.runTransaction(u).then(async d=>{if(d&&a){const $={};Object.entries(t).forEach(([f,I])=>{$[`${e.bookingId}.${f}`]=I}),await this.updateUserBooking({booking:e,data:$}),n!=null&&await this.realTimeEventsCounterHandler({workerId:e.workerId,businessId:e.buisnessId,increment:i,types:new Map([[n,1]])})}return d})}}class B{constructor({bookings:e,breaks:t}){g(this,"bookings",{});g(this,"breaks",[]);this.bookings=e,this.breaks=t}static empty(){return new B({bookings:{},breaks:[]})}merge(e){this.bookings={...this.bookings,...e.bookings},this.breaks=[...this.breaks,...e.breaks]}}class Z extends Je{constructor({title:t,day:s,shopIcon:a,id:r,start:i,note:n,blockSchedule:c,addedToDeviceCalendar:u=!1,color:d,workerId:$,businessModel:f,duration:I}){super();g(this,"title","");g(this,"timeId");g(this,"color",0);g(this,"duration",new K({}));g(this,"day","");g(this,"start","");g(this,"partOfRecurrence",!1);g(this,"note","");g(this,"id","");g(this,"blockSchedule",!0);g(this,"minutesNotification",60);g(this,"notify",!1);g(this,"addedToDeviceCalendar",!1);g(this,"shopIcon",new pe);const h=Ae(s),p=oe(i);this.bookingDate=new Date(h.getFullYear(),h.getMonth(),h.getDate(),p.getHours(),p.getMinutes()),this.businessName=f.shopName,this.buisnessId=f.businessId,this.workerId=$,this.title=t,this.day=s,this.shopIcon=a,this.id=r,this.start=i,this.note=n,this.blockSchedule=c,this.addedToDeviceCalendar=u,this.color=d,this.duration=I}static fromBreakModel(t){const s=new Z({title:t.title,day:t.day,shopIcon:t.shopIcon,id:t.id,start:t.start,note:t.note,blockSchedule:t.blockSchedule,addedToDeviceCalendar:t.addedToDeviceCalendar,color:t.color,workerId:t.workerId,businessModel:new ue({}),duration:t.duration});return s.recurrenceRef=t.recurrenceRef,s.recurrenceEventRefInfo=t.recurrenceEventRefInfo,s.partOfRecurrence=t.partOfRecurrence,s.timeId=t.timeId,s.recurrenceNotificationsLastDate=t.recurrenceNotificationsLastDate,s}static fromEvent(t){const s=new Z({title:t.eventName,day:M(t.from),shopIcon:t.breakIconData??new pe,id:t.breakId,start:le(t.from),note:t.note??"",blockSchedule:t.blockSchedule,addedToDeviceCalendar:t.breakAddedToDeviceCalendar,color:t.colorIndex,workerId:t.ids.length>0?t.ids[0]:"",businessModel:new ue({}),duration:new K({minutes:t.durationMinutes})});return s.recurrenceRef=t.breakFatherRecurrenceId,s.recurrenceEventRefInfo=t.recurrenceBreakRefInfo,s.recurrenceFatherDate=t.recurrenceBreakFatherDate,s.minutesNotification=t.minutesBreakNotification,s.notify=t.breakNotificaiton,s.partOfRecurrence=t.partOfRecurrence,s.timeId=t.timeId,s}get currentDisplayDate(){return this.recurrenceChildDate??this.bookingDate}reminder(t){if(!this.notify)return null;const s=Le(this);if(s<Ve()||t.fcmsTokens.size===0)return null;const a=`${this.buisnessId}--AAAA--${t.id}`;return new He({businessName:this.businessName,address:"",isRecurrence:this.recurrenceEvent!==null,id:a,shopIcon:this.shopIcon,phoneToContact:"",dateToNotify:s,isMulti:!1,minutesToAdd:ze()+this.minutesNotification,businessId:"",type:this.title!==""?this.title:P("break"),fcms:{...t.fcmsTokens}})}get timeIdAsKey(){return this.timeId!==void 0?`${this.start}_${this.timeId}`:this.start}}class ft extends ge{async deleteWorker({worker:e,workerId:t,createdAt:s,buisnessId:a,managerDeletion:r=!0,batch:i,fromBusinessDeletion:n=!1}){i||(i=this.getBatch);const c=new B({});if(!e){const h=await this.getDocRepo({path:`${y}/${a}/${E}`,docId:t});if(h.exists())e=se.fromWorkerDocJson(h.data());else return}const u=`${y}/${a}/${E}`,d=await this.getAllDocsAndIdsInsideCollection({path:`${u}/${e.id}/${l}/${m}/${v}`});if(Object.entries(d).forEach(([h,p])=>{Ae(h)>=be(new Date)&&Object.entries(p).forEach(([w,G])=>{const T=Ge.fromJson(G,w);c.bookings[T.bookingId]=T}),this.deleteDoc({batch:i,path:`${u}/${t}/${l}/${m}/${v}`,docId:h})}),n&&s){let h=s;for(;h<=new Date;){const p=F(h);Array.from({length:2},(w,G)=>{this.deleteDoc({batch:i,path:`${y}/${a}/${_e}/${t}/${p}`,docId:(G+1).toString()})}),this.deleteDoc({batch:i,path:`${y}/${a}/${Ke}/${t}/${Ze}`,docId:p}),h=qe(h,1)}}const $=await this.getAllDocsAndIdsInsideCollection({path:`${u}/${e.id}/${l}/${m}/${C}`});Object.entries($).forEach(([h,p])=>{Ye(h)>=Qe(new Date)&&(e.events.setEvents(p,e,h,{}),Object.entries(e.events.allEvents[h]??{}).forEach(([G,T])=>{Object.entries(T).forEach(([O,J])=>{if(J.isBreak){const L=Z.fromEvent(J);L.workerId=t,c.breaks.push(L)}})})),this.deleteDoc({batch:i,path:`${u}/${t}/${l}/${m}/${C}`,docId:h})}),(await this.getAllDocIdsInsideCollection({path:`${u}/${e.id}/${l}/${m}/${fe}`})).forEach(h=>{this.deleteDoc({batch:i,path:`${u}/${t}/${l}/${m}/${fe}`,docId:h})}),this.deleteDoc({batch:i,path:`${u}/${e.id}/${l}`,docId:x}),this.deleteDoc({batch:i,path:`${u}/${e.id}/${l}`,docId:Xe});const I=await this.getDocRepo({path:`${u}/${e.id}/${l}`,docId:Y});if(I.exists()){const h=new ue({});h.businessId=a,e.recurrence.setRecurrenceEvents(I.data(),t,h),Object.entries(e.recurrence.recurrenceEvents).forEach(([p,w])=>{Object.entries(w).forEach(([G,T])=>{if(T.recurrenceEvent==null||!T.isBreak)return;const O=Z.fromEvent(T);O.workerId=t,O.recurrenceNotificationsLastDate=e.notifications.recurrenceNotificationsLastDate,c.breaks.push(O)})}),this.deleteDoc({batch:i,path:`${u}/${e.id}/${l}`,docId:Y})}return this.deleteDoc({batch:i,path:`${u}/${e.id}/${l}`,docId:m}),!n&&r&&this.updateFieldInsideDocAsMap({batch:i,path:y,docId:a,fieldName:`workersIds.${e.id.replaceAll("+","")}`}),this.updateFieldInsideDocAsMapRepo({path:`${R}/${e.id}/${l}`,docId:m,fieldName:`permission.${a}`}),this.deleteDocRepo({path:`${u}/${e.id}/${l}`,docId:Be}),this.deleteDocRepo({path:`${u}/${e.id}/${l}`,docId:Y}),this.deleteDoc({batch:i,path:u,docId:e.id}),n||await this.removeChild({childPath:`${y}/${a}/${E}/${e.id}`}),n?c:(await this.getDocRepo({path:u,docId:e.id}).then(async h=>{if(h.exists()&&h.data()!=null){const p=se.fromWorkerDocJson(h.data()),w=new Set;Array.from(p.storyImages.values()).forEach(G=>{w.add(X.GI().getImageStorageName("story_images",G)+".jpg")})}}),await this.commmitBatch(i).then(h=>{if(h)return c}))}async deleteBuissness({user:e,businessId:t,customWorkers:s,workerProductId:a,fromDeleteUser:r=!1,productId:i}){const n=this.getBatch;let c={};const u=new B({});if(t===N.currentBusinesssId&&s!=null)c=s;else try{const f=await this.getAllDocInsideCollectionRepo({path:`${y}/${t}/${E}`});f!==null&&f.forEach(I=>{const h=se.fromWorkerDocJson(I);c[h.id]=h})}catch{}const d=[];if(Object.entries(c).forEach(([f,I])=>{I!=null&&d.push(this.deleteWorker({createdAt:I.createdAt,buisnessId:t,workerId:f,worker:I,fromBusinessDeletion:!0,batch:n}))}),(await Promise.all(d)).forEach(f=>{f!=null&&u.merge(f)}),this.deleteDoc({batch:n,path:y,docId:t}),!r){const f={};f[`businessesInfo.${t}`]=null,i!==""&&(f[`productsIds.${i}.businessId`]=""),a!==""&&(f[`productsIds.${a}.businessId`]=""),this.updateMultipleFieldsInsideDocAsMap({batch:n,path:R,docId:e.id,data:f})}return this.deleteDoc({batch:n,path:`${y}/${t}/${et}`,docId:tt}),await this.commmitBatch(n)?(this.removeChild({childPath:`${y}/${t}`}),u):null}}const z=class z{constructor(){g(this,"managerRepo",new ft)}static GI(){return z._singleton}async deleteWorker({buisnessId:e,workerId:t,worker:s}){const a=e.includes(o.GI().user.id.replaceAll("+","")),r=await this.managerRepo.deleteWorker({managerDeletion:a,workerId:t,buisnessId:e,worker:s});return e==N.currentBusinesssId&&(delete U.GI().workers[t],st.set(U.GI().workers)),r!==null}async deleteBuisness(e,t,s,a){return await this.managerRepo.deleteBuissness({user:o.GI().user,productId:s,customWorkers:U.GI().business.businessId===e?U.GI().workers:void 0,fromDeleteUser:t,workerProductId:a,businessId:e}).then(async r=>{if(r!==null){W.debug(`Finish delete buisness --> ${e}`),o.GI().user.businessesInfo.delete(e),s!==""&&o.GI().user.productsIds.set(s,new $e("",de.fromDate(new Date),s)),a!==""&&o.GI().user.productsIds.set(a,new $e("",de.fromDate(new Date),a)),o.GI().user.userPublicData.permission.delete(e);const i=o.GI().user.userPublicData.myBuisnessesIds.indexOf(e,0);i>-1&&o.GI().user.userPublicData.myBuisnessesIds.splice(i,1),e===U.GI().business.businessId&&U.GI().emptyBusinessData()}return r!==null})}};g(z,"_singleton",new z);let ee=z;const{v4:$t}=lt,_=class _{constructor(){g(this,"userRepo",new at);g(this,"verificationRepo",new rt)}static GI(){return _._singleton}async createUser({gender:e,phone:t,email:s,isVerifiedPhone:a,isVerifiedEmail:r,userName:i,authProvider:n,userId:c}){const u=await this.userRepo.getDocSRV({path:ae,docId:re(t)});if(u===void 0||u.exists()){b.GI().error=A.alreadyExistPhone;return}const d=new ie({id:c,name:i,email:s,isVerifiedPhone:a,isVerifiedEmail:r,phoneNumber:t,myBuisnessesIds:[],lastVisitedBuisnessesRemoved:[],lastVisitedBuisnesses:[],revenueCatId:$t(),gender:e});console.log("currentUser",d),d.authProviders=n?new Map([[n,new Date]]):new Map;let $;if(n===it.Phone&&a&&($=await this.mergePhoneCollectionWithUser(d,t),$||(d.isVerifiedPhone=!1)),!!await this.userRepo.createUser({user:d}))return $||new S}async deleteUser(e){if(we.GI().lastLoginDate==null||nt(ot(we.GI().lastLoginDate),ct)>new Date)return b.GI().error=A.bigDiffrentBetweenLoginAndDelete,!1;await this._beforeLogout();const t=[...Object.keys(o.GI().user.userPublicData.permission)];await Promise.all(t.map(async a=>{if(o.GI().user.userPublicData.permission.get(a)===1)return await ee.GI().deleteWorker({workerId:e.id,buisnessId:a})}));const s=[...o.GI().user.userPublicData.myBuisnessesIds];return await Promise.all(s.map(async a=>await ee.GI().deleteBuisness(a,!0,"",""))),await o.GI().getAllBookingsDocs(),await this.markUserDeletedOnAllWorkerBookings(),await this.userRepo.deleteUser({user:e}),await this.verificationRepo.deleteUser().then(async a=>(a&&(o.GI().user=new ie({name:"guest"}),H.set(o.GI().user),Ie.set(!1)),a))}async logout(){return await this._beforeLogout(),await this.verificationRepo.logout().then(async e=>(e&&(o.GI().user=new ie({name:"guest"}),H.set(o.GI().user),Ie.set(!1)),e))}async _beforeLogout(){o.GI().cancelPublicDataListening(o.GI().user)}async markUserDeletedOnAllWorkerBookings(){const e=[];Object.entries(o.GI().user.bookings.all).forEach(([t,s])=>{s.workerDeleted||e.push(this.userRepo.updateFieldInsideDocAsMapRepo({path:`${y}/${s.buisnessId}/${E}/${s.workerId}/${l}/${m}/${v}`,docId:M(s.bookingDate),fieldName:s.isMultiRef?`${le(s.bookingDate)}.users.${t}.userDeleted`:`${t}.userDeleted`,value:!0}))}),await Promise.all(e)}async mergePhoneCollectionWithUser(e,t){const s=await this.userRepo.mergePhoneDataWithUser({phone:t,userId:e.id,name:e.name});if(!(s===void 0&&b.GI().error===A.alreadyExistPhone))return s}async updateCreditCardsPassword(e,t){const s={},a={};return e!==""&&Object.entries(o.GI().user.paymentCards).forEach(([r,i])=>{Object.entries(i).forEach(([n,c])=>{const d=c.decryptCard(e).encryptCard(t);s[r]??(s[r]={}),s[r][n]=d,a[r]??(a[r]={}),a[r][n]=d.toJson()})}),await this.userRepo.updateMultipleFieldsInsideDocAsMapRepo({docId:o.GI().user.id,path:R,data:{cardPaymentsPass:me(t),paymentCards:a}}).then(async r=>(r&&(o.GI().user.cardPaymentsPass=me(t),o.GI().user.paymentCards=s),r))}async updateEmail(e,{isVerified:t=!1}={}){return ht(e)!==null?(b.GI().error=A.illegalFields,!1):e===o.GI().user.userPublicData.email?!0:Q(o.GI().user.lastTimeUpdateEmail,new K({days:1}))>new Date?(b.GI().error=A.cantUpdateEmailTooShortTimeBetween,!1):(o.GI().user.userPublicData.email=e,await this.userRepo.updateMultipleFieldsInsideDocAsMapRepo({path:`${R}/${o.GI().user.id}/${l}`,docId:m,data:{email:e,isVerifiedEmail:t}}).then(async s=>{if(s){o.GI().user.userPublicData.isVerifiedEmail=t;const a=new Date;return await this.userRepo.updateFieldInsideDocAsMapRepo({path:R,docId:o.GI().user.id,fieldName:"lastTimeUpdateEmail",value:a.toString()}).then(r=>(r&&(o.GI().user.lastTimeUpdateEmail=a),r))}return s}))}async updateSeenUpdates(e,t){return new Set([...o.GI().user.seenUpdates[e]].filter(a=>t.has(a))).size===t.size?!0:(o.GI().user.seenUpdates[e]=new Set([...t]),await this.userRepo.updateFieldInsideDocAsMapRepo({path:R,docId:o.GI().user.id,fieldName:`seenUpdates.${e}`,value:Array.from(t)}))}async setGender(e){return e===o.GI().user.gender?(console.log("22222222222222222222"),!0):(console.log("eeeeeeeeeeeeeeeee"),o.GI().user.gender=e,H.set(o.GI().user),await this.userRepo.updatePublicUserField({userId:o.GI().user.id,fieldName:"gender",value:dt[e],businessesIds:Object.keys(o.GI().user.userPublicData.permission)}).then(t=>(console.log("33333333333",t),t)))}async updateName(e){if(e===o.GI().user.name)return!0;const t=o.GI().user;return t.name=e,await this.userRepo.updatePublicUserField({userId:t.id,businessesIds:Object.keys(t.userPublicData.permission),fieldName:"name",value:e}).then(async s=>{if(s){const a=[];t.userPublicData.myBuisnessesIds.forEach(r=>{a.push(this.userRepo.updateFieldInsideDocAsMapRepo({fieldName:"ownersName",docId:r,path:y,value:e}).then(i=>{i&&r==N.currentBusinesssId&&(U.GI().business.ownersName=e)}))}),t.isVerifiedPhone&&a.push(this.userRepo.updateFieldInsideDocAsMapRepo({fieldName:"name",docId:re(t.phoneNumber),path:ae,value:e})),await Promise.all(a)}return s})}async addOrRemoveLikeForStoryImage(e,t,s,a){var i;const r=await this.userRepo.updateFieldInsideDocAsArrayRepo({path:R,docId:s,fieldName:"storyLikes",value:e,command:a});if(r){const n=((i=U.GI().workers[t])==null?void 0:i.storylikesAmount[e])??0;a===ut.add?(await this.userRepo.incrementNumberChild({childPath:X.GI().getLisksChildPath(t),valueId:e,delta:1,command:k.increment}),o.GI().user.storyLikes.push(e),U.GI().workers[t]&&(U.GI().workers[t].storylikesAmount[e]=n+1)):(n>=0&&(await this.userRepo.incrementNumberChild({childPath:X.GI().getLisksChildPath(t),valueId:e,delta:1,command:k.decrement}),U.GI().workers[t]&&(U.GI().workers[t].storylikesAmount[e]=Math.max(U.GI().workers[t].storylikesAmount[e]-1,0))),o.GI().user.storyLikes=o.GI().user.storyLikes.filter(c=>c!=e))}return r}async addAuthProvider({provider:e,isVerifiedPhone:t,phone:s,isVerfiedEmail:a,email:r}){if(o.GI().user.authProviders.has(e))return new S;const i=new Date;o.GI().user.authProviders.set(e,i);const n={};if(o.GI().user.authProviders.forEach((u,d)=>{De[d]!==null&&(n[De[d]]=j(u))}),!await this.userRepo.updateFieldInsideDocAsMapRepo({docId:o.GI().user.id,path:R,fieldName:"authProviders",value:n}))o.GI().user.authProviders.delete(e);else{let u=new S;return s!=null&&t===!0&&(u=await this.updatePhone(s,t===!0)),r!=null&&await this.updateEmail(r,{isVerified:a===!0}),H.set(o.GI().user),u}return new S}async updatePhone(e,t){if(o.GI().user.phoneNumber===e&&t===o.GI().user.isVerifiedPhone)return new S;if(o.GI().user.phoneNumber!==e&&Q(o.GI().user.lastTimeUpdatePhone,new K({days:1}))>new Date){b.GI().error=A.cantUpdatePhonelTooShortTimeBetween;return}let s;if(t&&(s=await this.mergePhoneCollectionWithUser(o.GI().user,e),s==null&&(t=!1,o.GI().user.phoneNumber===e&&t===o.GI().user.isVerifiedPhone)))return new S;if((o.GI().user.isVerifiedPhone&&!t||o.GI().user.isVerifiedPhone&&o.GI().user.phoneNumber!==e)&&!await this.userRepo.deleteDocRepo({path:ae,docId:re(o.GI().user.phoneNumber)}))return;if(await this.userRepo.updatePhone({currentPhone:o.GI().user.phoneNumber,userId:o.GI().user.id,businessesIds:Object.keys(o.GI().user.userPublicData.permission),phone:e,isVerified:t})){const r=new Date;return await this.updateAllClients(o.GI().user.id,e,t),o.GI().user.phoneNumber!==e?(await this.userRepo.updateFieldInsideDocAsMapRepo({path:R,docId:o.GI().user.id,fieldName:"lastTimeUpdatePhone",value:r.toISOString()}).then(i=>{i&&(o.GI().user.lastTimeUpdatePhone=r)}),await this.handleScheduleMessgesPhoneChange(e),await this.handleExistBookingsPhoneChange(e)):await this.makeReminderToAllBookingsWithoutRemminder(t),o.GI().user.phoneNumber=e,o.GI().user.userPublicData.phoneNumber=e,o.GI().user.isVerifiedPhone=t,o.GI().user.userPublicData.isVerifiedPhone=t,H.set(o.GI().user),s??new S}}async handleScheduleMessgesPhoneChange(e){}async makeReminderToAllBookingsWithoutRemminder(e){}async handleExistBookingsPhoneChange(e){const t={};await o.GI().getAllBookingsDocs();const s=new pt,a=o.GI().user.bookings.all;Object.entries(a).forEach(([i,n])=>{n.customerPhone=e,!n.workerDeleted&&(t[i]=n)});const r=[];Object.entries(t).forEach(([i,n])=>{n.isMultiRef||r.push(s.updateFieldsInBooking({booking:n,data:{customerPhone:e}}))}),await Promise.all(r)}async updateAllClients(e,t,s){const a=o.GI().user.userPublicData.clientAt,r=[];return a.forEach((n,c)=>{const u=`${y}/${c}/${E}`;n.forEach(d=>{r.push(this.userRepo.updateMultipleFieldsInsideDocAsMapRepo({path:`${u}/${d}/${l}`,docId:x,data:{[`data.${e}.isVerifiedPhone`]:s,[`data.${e}.phoneNumber`]:t}}))})}),!(await Promise.all(r)).includes(!1)}};g(_,"_singleton",new _);let Ee=_;export{pt as B,Ee as U,yt as a,ht as e,Et as n};
